Γενικες σημειωσεις copy-paste απο τις διαφανειες της θεωριας με θεμα τα SCRIPTS

---PDF 10 - Scripts

Για ένα shell script η πρώτη γραμμή πρέπει να είναι: #!/bin/bash
Σχολια γινονται με : #
Η κληση των script γινεται γενικως με ./scriptname
Επιλογή –v για να εμφανίζεται στην οθόνη κάθε γραμμή του σεναρίου καθώς αυτό διαβάζεται.
Επιλογή –x για να εμφανίζονται οι εντολές, καθώς εκτελούνται.                                    (!!!!!ΜΠΑΙΝΟΥΝ ΜΕΤΑ ΤΟ #!/BIN/BASH)

---PDF 11 - Variables & Quotes
 
Ολες οι μεταβλητες ειναι string και δεν οριζονται τυποι πχ a=5 ή a="5" (Προσοχη να μην υπαρχουν κενα ΚΑΙ σε ειδικους χαρακτηρες, χρηση \ για αναιρεση σημασιας)

env    :Τυπωνει ολες τις μεταβλητες περιβαλλοντος     
read a :Εκχωρει στην μεταβλητη a οτιδηποτε εισαγεται απο το πληκτρολογιο 

	Η επιλογή -n στην echo δεν αλλάζει γραμμή μετά την εκτύπωση του μηνύματος. Η read θα διαβάσει μέχρι να πατήσουμε "αλλαγή γραμμής" (Enter).
	Η χρήση μιας μεταβλητής (δηλαδή της τιμής που περιέχει) γίνεται χρησιμοποιώντας τον χαρακτήρα $.
	-Ο $ "λέει" στο shell να θεωρήσει την λέξη (string) που ακολουθεί ως όνομα μεταβλητής και να χρησιμοποιήσει την τιμή της.
	Γενικώς τα εισαγωγικά αγνοούνται από το shell, και δεν περιλαμβάνονται τα ίδια στις τιμές των Strings (Το shell αγνοεί τα πολλαπλά κενά αν αυτά δεν είναι μέσα σε εισαγωγικά)
	-Καλό είναι όταν αναθέτουμε τιμή σε μια μεταβλητή ή όταν χρησιμοποιούμε μια μεταβλητή να χρησιμοποιούμε εισαγωγικά.
	Αν δεν χρησιμοποιούμε εισαγωγικά θα ερμηνευτούν οι ειδικοί χαρακτήρες. (το * είναι ειδικός χαρακτήρας) πχ διαφορα μεταξυ a='*' echo "$a" και echo $a
!!SOS!! Τα απλά εισαγωγικά (‘single quotes’) άρουν την μεταχαρακτηρική ιδιότητα όλων των συμβόλων εκτός από τον εαυτό τους.
!!SOS!!	Τα διπλά εισαγωγικά (“double quotes”) άρουν την μεταχαρακτηρική ιδιότητα όλων των συμβόλων εκτός από τον εαυτό τους, την ανάποδη κάθετο (backslash \ ) και το δολάριο ($).
!!SOS!!	Τα ανάποδα εισαγωγικά (`back quotes`) προκαλούν την εκτέλεση της εντολής που περικλείουν.Πχ a=`ls -all` echo "$a" θα εκτελεσει την ls -all οπου το αποτελεσμα αποθηκευεται στην a
	Μέσα στα διπλά εισαγωγικά ερμηνεύονται οι μεταβλητές (μεταβλητές του shell αλλά και οι μεταβλητές περιβάλλοντος)
	Μέσα στα μονά εισαγωγικά ΔΕΝ ερμηνεύονται οι μεταβλητές - δηλαδή αναιρείται η ειδική σημασία του χαρακτήρα $.

{}     :To shell όταν βρίσκει το χαρακτήρα $, θεωρεί ότι αυτό που ακολουθεί (μέχρι κάποιον ειδικό χαρακτήρα ή κενό) είναι όνομα μεταβλητής και το αντικαθιστά με την τιμή του.
	Οποτε αν θελουμε να γραψουμε χαρακτηρες διπλα απο την μεταβλητη χωρις κενα χρησιμοποιουμε {}.Πχ a='1  ' echo ${a}apple -> 1  apple

expr   :Χρησιμοποιειται για αριθμητικες πραξεις.Πχ expr 1+2->3,a=5 expr "$a"-10->-5 ΠΡΟΣΟΧΗ!!!!Στον πολλαπλασιασμο χρηση '*' ή \* για απενεργοποιηση ειδικε σημασιας
	Με την χρήση ` μπορούμε να εκχωρήσουμε το αποτέλεσμα των πράξεων σε μεταβλητη.Πχ a=60 b=40 a=`expr "$a" + "$b"` echo "$a"->100 !!!!!!ΠΡΟΣΟΧΗ στα κενα πριν και μετα το +
	Το bas γνωριζει να κανει αριθμητικες πραξεις.Πχ a=50 b=100 a=$((a+b)) echo "$a"->150
	Επισης προσοχη το $ ερμηνευεται πριν την πραξη αρα αν βαλουμε string σε μια μεταβλητη β το οποιο ειναι το ονομα της μεταβλητης γ το α=$(($α+$β)) θα γινει α=$(($α+γ))


---PDF 12 - Arguments + For

Ειδικες μεταβλητες φλοιου:
$1 - $9  Οι παράμετροι στο script
$0 	 το όνομα της εντολής (όπως το έδωσε ο χρήστης)
$# 	 το πλήθος των παραμέτρων
$* 	 ένα string που περιλαμβάνει όλες τις παραμέτρους
$@ 	 το ίδιο με το $*, εκτός αν χρησιμοποιούνται εισαγωγικά (είναι πίνακας) 
$$	 ο αριθμός διεργασίας (PID) του φλοιού
$! 	 Ο αριθμός διεργασίας της διεργασίας που εκτελείται (εκτελέστηκε) στο παρασκήνιο
$?	 Η κατάσταση εξόδου (exit status) της εντολής που εκτελέστηκε τελευταία .
${10}-.. Στο bash υπάρχουν και τα ορίσματα >=10 χρησιμοποιώντας {}.


for     :Συντασετε-> for i in 1 2 3 4; do     H σωστη μεθοδος για να διατρεξουμε ολες τις παραμετρους      Για αριθμητικες πραξεις μεσα σε (()) ισχυει το ιδιο
		        //ΕΝΤΟΛΕΣ             ειναι με τη χρηση του "$@"				   συντακτικο παρομοιο με C,Java.
		     done
		ή 
	             for ((expression; expression; expression)) 
		     do
			commands
		     done

---PDF 13 - Test, If

	Υπάρχει η σύμβαση, όταν η εκτέλεση του προγράμματος ήταν πετυχημένη η διεργασία επιστρέφει 0. Διαφορετικά επιστρέφει έναν ακέραιο που εκφράζει το σφάλμα.
	Το shell διαβάζει τον κωδικό που επέστρεψε η κάθε εντολή και τον αποθηκεύει στην μεταβλητή $?.
	-Με την χρηση && μπορουμε να ομαδοποιησουμε εντολες ετσι ωστε αν η μια βγαλει error exit code τοτε η αλλη δεν θα εκτελεστει.Πχ ls -l zxy && stat out-0013.pdf 
	,δηλαδη η stat δεν θα εκτελεστει αν δεν υπαρχει το zxy αρχειο και αρα εμφανισει error η ls.
	-Με την χρηση || αν η 1η εντολη εκτελεστει σωστα, τοτε δεν εκτελουνται οι υπολοιπες.Αν η 1η εντολη δεν εκτελεστει σωστα τοτε εκτελειται ΚΑΙ η επομενη.Πχ wc -l "$file" || echo "File $file NOT FOUND" 
	-Με την χρηση ! υλοποιουμε λογικο ΝΟΤ.!!!ΠΡΟΣΟΧΗ πρεπει να υπαρχει κενο αναμεσα στο ! και την εντολη πχ ! wc -l "$file" && echo "File $file NOT FOUND"
	!!!ΠΡΟΣΟΧΗ Στην περίπτωση της διασωλήνωσης δεν υπολογίζεται το συνολικό "exit status" όλων των εντολών, αλλά στο $? αποθηκεύεται μόνο της τελευταίας.

if     :Συντασετε->if entolh-elegxou ; then       
		      Commands….
		   elif entolh-elegxou ; then         !!!ΠΡΟΣΟΧΗ δεν μπορει να κανει ελγχο αποτελεσματων αριθμητικες πραξης ή συγκριση string
		      Commands….			 Δες test
		   else
		      Commands….
		   fi

test   :Δέχεται ως όρισμα μια συνθήκη-έλεγχο και επιστέφει ως exit code true(0) ή false(>0)
	
	Ελεγχοι για string:
	-z string              True if string is empty.
	-n string              True if string is not empty.
	string1 = string2      True if string1 equals string2.
	string1 != string2     True if string1 does not equal string2

	Ελεγχοι σε ακεραιους:
	INTEGER1 -eq INTEGER2    INTEGER1 = INTEGER2   πχ test '5' -eq '005'
	INTEGER1 -ne INTEGER2    INTEGER1 != INTEGER2
	INTEGER1 -ge INTEGER2    INTEGER1 >= INTEGER2
	INTEGER1 -gt INTEGER2    INTEGER1 > INTEGER2   πχ test 5 -gt 10
	INTEGER1 -le INTEGER2    INTEGER1 <= INTEGER2
	INTEGER1 -lt INTEGER2    INTEGER1 < INTEGER2

	Ελεγχοι σε αρχεια:
	-d file            True if file is a directory.
	-e file 	   True if file exists.
	-f file 	   True if file exists and is a regular file.
	-L file 	   True if file is a symbolic link.
	-r file 	   True if file is a file readable by you.
	-w file 	   True if file is a file writable by you.
	-x file 	   True if file is a file executable by you.
	-s file 	   Τrue if file exists and has a size greater than zero.
	file1 -nt file2    True if file1 is newer than (according to modification time) file2
	file1 -ot file2    True if file1 is older than file2

	Λογικοι τελεστες:
	! 	   unary negation operator.
	-a 	   binary AND operator.
	-o         binary ΟR operator (-a has higher precedence than -o).
	( expr )   parentheses for grouping.

	!!!ΠΡΟΣΟΧΗ για χρηση παρενθεσεων χρειαζεται το \ για την αναιρεση της ειδικης σημασιας

	-Παραδειγμα χρησης If + test

	echo -n "give a number less than 10: "
	read a
	if test "$a" –ge 10 ; then
	   echo "You gave wrong number"
	else
	   echo "OK. You gave $a"
	fi

[]     :Το [] ειναι ισοδυναμο με την εντολη test,πχ if [ "$a" –ge 10 ]; then .........
	!!!ΠΡΟΣΟΧΗ στα κενα μετα το [ και πριν το ].Γενικως βαλε παντου γαμημενα κενα.Εκτος απο τις παρενθεσεις (()) οπου χρησιμοποιουνται για αριθμητικες πραξεις και ελεγχους οπως αναφερθηκε παραπανω.


---PDF 14 - while,case,shift

while  :Συνταξη-> while [ συνθηκη ]; do     Μπορει να γινει και χρηση (()) αντι για []
		     //ΕΝΤΟΛΕΣ 	 	    Οπως και σε αλλες γλωσσες γινεται εδω χρηση δεικτη πχ i,j κτλπ
		  done
	
until  :Συνταξη-> until [ συνθηκη ]; do 
		    //ΕΝΤΟΛΕΣ
		  done

case   :Συνταξη-> case "$μεταβλητη" in
		  περιπτωση1) //ΕΝΤΟΛΕΣ ;;	Για τις περιπτωσεις ισχυουν οι ιδιοι κανονες με τα wildcards πχ [yY],[nN],*,[kati]|[katiallo]
		  περιπτωση2) //ΕΝΤΟΛΕΣ ;;
		  done

shift  :H εντολή shift μετακινεί τα στοιχεία του πίνακα ορισμάτων.Προαιρετικά δέχεται όρισμα το πλήθος των στοιχείων μετακίνησης.Το πρώτο στοιχείο από τον πίνακα ορισμάτων χάνεται 


---PDF 5 ΕΡΓΑΣΤΗΡΙΟ

1>&2   :Τυπωνει στην επομενη εξοδο στο stderr,δλδ ανακατευθυνει το stream απο το 1 στο 2
	
	H read αντί να διαβάζει από την κανονική είσοδο του script, να της δώσουμε να διαβάζει από αρχείο οπως: i=2
														file="file1"
	Με αυτον τον τροπο ολες οι εντολες που βρισκονται μεσα στο block εντολων της while κληρονομουν		while read a; do
	ως κανονικη εισοδο το αρχειο $file									echo "line$i: $a"
														i=$((i+1))
														done < "$file"

set    :Η εντολή set, δέχεται διάφορα ορίσματα και τα καταχωρεί στις μεταβλητές $1,$2,…$9 όπως επίσης γεμίζει και τις #$, $*, $@. Μια λεξη ανα ορισμα

cut    :Η εντολή cut, είναι φίλτρο, διαβάζει την είσοδό της και τυπώνει στην έξοδο το αποτέλεσμα.Χρησιμοποιείται για να επιλέξει συγκεκριμένες "στήλες" από την είσοδο. Πχ:
	ls –l | cut –c1-10,14-18 -> τυπώνει από την είσοδο τους χαρακτήρες 1ο – 10ο και 14ο -18ο από κάθε γραμμή.
	cat /etc/group | cut –d ':' –f1,3 -> τυπώνει από την είσοδο τους χαρακτήρες το 1ο και 3ο πεδίο θεωρώντας ως διαχωριστή το ":".
	!!!ΠΡΟΣΟΧΗ η cut δεν αγνοεί τα πολλαπλά κενά (ή γενικώς πολλές επαναλήψεις του διαχωριστή).

uniq   :Η εντολή uniq, είναι φίλτρο, διαβάζει την είσοδό της και το τυπώνει στην έξοδο, χωρίς όμως να τυπώνει όμοιες 2 γραμμές συνεχόμενες.Χρησιμοποιείται για να τυπώσει τις 
	μοναδικές γραμμές από ένα αρχείο σε συνδυασμό με την sort (ώστε όλες οι όμοιες γραμμές να είναι συνεχόμενες).Επίσης με το όρισμα –c μετράει και τις εμφανίσεις.
     Πχ cut –d ':' –f7 /etc/passwd -> Μας ενδιαφερει η 7η στηλη
	cut –d ':' –f7 /etc/passwd | sort -> Τις ταξινομουμε
	cut –d ':' –f7 /etc/passwd | sort | uniq -c -> Εμφανιζουμε τις μοναδικες (και τις μετραμε)

























